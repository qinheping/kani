window.SIDEBAR_ITEMS = {"attr":[["proof","Marks a Kani proof harness"],["should_panic",""],["solver","Select the SAT solver to use with CBMC for this harness The attribute `#[kani::solver(arg)]` can only be used alongside `#[kani::proof]``"],["stub","Specify a function/method stub pair to use for proof harness"],["unwind","Set Loop unwind limit for proof harnesses The attribute ‘#[kani::unwind(arg)]’ can only be called alongside ‘#[kani::proof]’. arg - Takes in a integer value (u32) that represents the unwind value for the harness."]],"derive":[["Arbitrary","Allow users to auto generate Arbitrary implementations by using `#[derive(Arbitrary)]` macro."]],"fn":[["any","This creates an symbolic valid value of type `T`. You can assign the return value of this function to a variable that you want to make symbolic."],["any_where","This creates a symbolic valid value of type `T`. The value is constrained to be a value accepted by the predicate passed to the filter. You can assign the return value of this function to a variable that you want to make symbolic."],["assert","Creates an assertion of the specified condition and message."],["assume","Creates an assumption that will be valid after this statement run. Note that the assumption will only be applied for paths that follow the assumption. If the assumption doesn’t hold, the program will exit successfully."],["cover","Creates a cover property with the specified condition and message."]],"macro":[["cover","A macro to check if a condition is satisfiable at a specific location in the code."]],"mod":[["arbitrary","This module introduces the Arbitrary trait as well as implementation for primitive types and other std containers."],["futures","This module contains functions to work with futures (and async/.await) in Kani."],["slice",""],["tuple","Support for arbitrary tuples where each element implements `kani::Arbitrary`. Tuples of size up to 12 are supported in this file."],["vec",""]]};