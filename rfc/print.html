<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kani RFC Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Design documents for Kani Rust Verifier">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="template.html">RFC Template</a></li><li class="chapter-item expanded affix "><li class="part-title">Kani RFCs</li><li class="chapter-item expanded "><a href="rfcs/0001-mir-linker.html">0001-mir-linker</a></li><li class="chapter-item expanded "><a href="rfcs/0002-function-stubbing.html">0002-function-stubbing</a></li><li class="chapter-item expanded "><a href="rfcs/0003-cover-statement.html">0003-cover-statement</a></li><li class="chapter-item expanded "><a href="rfcs/0005-should-panic-attr.html">0005-should-panic-attr</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kani RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/model-checking/kani" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Kani is an open-source verification tool that uses automated reasoning to analyze Rust programs. In order to
integrate feedback from developers and users on future changes to Kani, we decided to follow a light-weight
&quot;RFC&quot; (request for comments) process.</p>
<h2 id="when-to-create-an-rfc"><a class="header" href="#when-to-create-an-rfc">When to create an RFC</a></h2>
<p>You should create an RFC in one of two cases:</p>
<ol>
<li>The change you are proposing would be a &quot;one way door&quot;: e.g. a change to the public API, a new feature that would be difficult to modify once released, deprecating a feature, etc.</li>
<li>The change you are making has a significant design component, and would benefit from a design review.</li>
</ol>
<p>Bugs and smaller improvements to existing features do not require an RFC.
If you are in doubt, feel free to create  a <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=&amp;template=feature_request.md">feature request</a> and discuss the next steps in the new issue.
Your PR reviewer may also request an RFC if your change appears to fall into category 1 or 2.</p>
<p>You do not necessarily need to create an RFC immediately. It is our experience that it is often best to write some &quot;proof of concept&quot; code to test out possible ideas before writing the formal RFC.</p>
<h2 id="the-rfc-process"><a class="header" href="#the-rfc-process">The RFC process</a></h2>
<p>This is the overall workflow for the RFC process:</p>
<pre><code class="language-toml">    Create RFC ──&gt; Receive Feedback  ──&gt; Accepted?
                        │  ∧                  │ Y
                        ∨  │                  ├───&gt; Implement ───&gt; Test + Feedback ───&gt; Stabilize?
                       Revise                 │ N                                          │ Y
                                              └───&gt; Close PR                               ├───&gt; RFC Stable
                                                                                           │ N
                                                                                           └───&gt; Remove feature
</code></pre>
<ol>
<li>Create an RFC
<ol>
<li>Create a tracking issue for your RFC (e.g.: <a href="https://github.com/model-checking/kani/issues/1588">Issue-1588</a>).</li>
<li>Start from a fork of the Kani repository.</li>
<li>Copy the template file (<a href="./template.html"><code>rfc/src/template.md</code></a>) to <code>rfc/src/rfcs/&lt;ID_NUMBER&gt;&lt;my-feature&gt;.md</code>.</li>
<li>Fill in the details according to the template instructions.</li>
<li>Add a link to the new RFC inside <a href="https://github.com/model-checking/kani/blob/main/rfc/src/SUMMARY.md"><code>rfc/src/SUMMARY.md</code></a></li>
<li>Submit a pull request.</li>
</ol>
</li>
<li>Build consensus and integrate feedback.
<ol>
<li>RFCs should get approved by at least 2 Kani developers.</li>
<li>Once the RFC has been approved, update the RFC status and merge the PR.</li>
<li>If the RFC is not approved, close the PR without merging.</li>
</ol>
</li>
<li>Feature implementation.
<ol>
<li>Start implementing the new feature in your fork.</li>
<li>It is OK to implement it incrementally over multiple PRs. Just ensure that every pull request has a testable
end-to-end flow and that it is properly tested.</li>
<li>In the implementation stage, the feature should only be accessible if the user explicitly passes
<code>--enable-unstable</code> as an argument to Kani.</li>
<li>Document how to use the feature.</li>
<li>Keep the RFC up-to-date with the decisions you make during implementation.</li>
</ol>
</li>
<li>Test and Gather Feedback.
<ol>
<li>Fix major issues related to the new feature.</li>
<li>Gather user feedback and make necessary adjustments.</li>
<li>Add lots of tests.</li>
</ol>
</li>
<li>Stabilization.
<ol>
<li>Propose to stabilize the feature when feature is well tested and UX has received positive feedback.</li>
<li>Create a new PR that removes the <code>--enable-unstable</code> guard and that marks the RFC status as &quot;STABLE&quot;.
<ol>
<li>Make sure the RFC reflects the final implementation and user experience.</li>
</ol>
</li>
<li>In some cases, we might decide not to incorporate a feature
(E.g.: performance degradation, bad user experience, better alternative).
In those cases, please update the RFC status to &quot;CANCELLED as per &lt;PR_LINK | ISSUE_LINK&gt;&quot; and remove the code
that is no longer relevant.</li>
<li>Close the tracking issue.</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> <em>Fill me with pretty name and a unique ident. E.g: New Feature (<code>new_feature</code>)</em></li>
<li><strong>Feature Request Issue:</strong> <em>Link to issue</em></li>
<li><strong>RFC PR:</strong> <em>Link to original PR</em></li>
<li><strong>Status:</strong> <em>One of the following: [Under Review | Unstable | Stable | Cancelled]</em></li>
<li><strong>Version:</strong> [0-9]* <em>Increment this version whenever you open a new PR to update the RFC (not at every revision).
Start with 0.</em></li>
<li><strong>Proof-of-concept:</strong> <em>Optional field. If you have implemented a proof of concept, add a link here</em></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Short description of the feature, i.e.: the elevator pitch. What is this feature about?</p>
<h2 id="user-impact"><a class="header" href="#user-impact">User Impact</a></h2>
<p>Why are we doing this? How will this benefit the final user?</p>
<ul>
<li>If this is an API change, how will that impact current users?</li>
<li>For deprecation or breaking changes, how will the transition look like?</li>
<li>If this RFC is related to change in the architecture without major user impact, think about the long term
impact for user. I.e.: what future work will this enable.</li>
</ul>
<h2 id="user-experience"><a class="header" href="#user-experience">User Experience</a></h2>
<p>What is the scope of this RFC? Which use cases do you have in mind? Explain how users will interact with it. Also
please include:</p>
<ul>
<li>How would you teach this feature to users? What changes will be required to the user documentation?</li>
<li>If the RFC is related to architectural changes and there are no visible changes to UX, please state so.</li>
</ul>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h2>
<p>This is the technical portion of the RFC. Please provide high level details of the implementation you have in mind:</p>
<ul>
<li>What are the main components that will be modified? (E.g.: changes to <code>kani-compiler</code>, <code>kani-driver</code>, metadata,
installation...)</li>
<li>How will they be modified? Any changes to how these components communicate?</li>
<li>Will this require any new dependency?</li>
<li>What corner cases do you anticipate?</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<ul>
<li>What are the pros and cons of this design?</li>
<li>What is the impact of not doing this?</li>
<li>What other designs have you considered? Why didn't you choose them?</li>
</ul>
<h2 id="open-questions"><a class="header" href="#open-questions">Open questions</a></h2>
<ul>
<li>Is there any part of the design that you expect to resolve through the RFC process?</li>
<li>What kind of user feedback do you expect to gather before stabilization? How will this impact your design?</li>
</ul>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<p>What are natural extensions and possible improvements that you predict for this feature that is out of the
scope of this RFC? Feel free to brainstorm here.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> MIR Linker (mir_linker)</li>
<li><strong>RFC Tracking Issue</strong>: <a href="https://github.com/model-checking/kani/issues/1588">https://github.com/model-checking/kani/issues/1588</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/1600">https://github.com/model-checking/kani/pull/1600</a></li>
<li><strong>Status:</strong> Stable</li>
<li><strong>Version:</strong> 3</li>
</ul>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Fix linking issues with the rust standard library in a scalable manner by only generating goto-program for
code that is reachable from the user harnesses.</p>
<h2 id="user-impact-1"><a class="header" href="#user-impact-1">User Impact</a></h2>
<p>The main goal of this RFC is to enable Kani users to link against all supported constructs from the <code>std</code> library.
Currently, Kani will only link to items that are either generic or have an inline annotation.</p>
<p>The approach introduced in this RFC will have the following secondary benefits.</p>
<ul>
<li>Reduce spurious warnings about unsupported features for cases where the feature is not reachable from any harness.</li>
<li>In the verification mode, we will likely see a reduction on the compilation time and memory consumption
by pruning the inputs of symtab2gb and goto-instrument.
<ul>
<li>Compared to linking against the standard library goto-models that take more than 5 GB.</li>
</ul>
</li>
<li>In a potential assessment mode, only analyze code that is reachable from all public items in the target crate.</li>
</ul>
<p>One downside is that we will include a pre-compiled version of the std, our release bundle will double in size
(See <a href="rfcs/0001-mir-linker.html#rational-and-alternatives">Rational and Alternatives</a>
for more information on the size overhead).
This will negatively impact the time taken to set up Kani
(triggered by either the first time a user invokes <code>kani | cargo-kani</code> , or explicit invoke the subcommand <code>setup</code>).</p>
<h2 id="user-experience-1"><a class="header" href="#user-experience-1">User Experience</a></h2>
<p>Once this RFC has been stabilized users shall use Kani in the same manner as they have been today.
Until then, we wil add an unstable option <code>--mir-linker</code> to enable the cross-crate reachability analysis
and the generation of the goto-program only when compiling the target crate.</p>
<p>Kani setup will likely take longer and more disk space as mentioned in the section above.
This change will not be guarded by <code>--mir-linker</code> option above.</p>
<h2 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed Design</a></h2>
<p>In a nutshell, we will no longer generate a goto-program for every crate we compile.
Instead, we will generate the MIR for every crate, and we will generate only one goto-program.
This model will only include items reachable from the target crate's harnesses.</p>
<p>The current system flow for a crate verification is the following (Kani here represents either <code>kani | cargo-kani</code>
executable):</p>
<ol>
<li>Kani compiles the user crate as well as all its dependencies.
For every crate compiled, <code>kani-compiler</code> will generate a goto-program.
This model includes everything reachable from the crate's public functions.</li>
<li>After that, Kani links all models together by invoking <code>goto-cc</code>.
This step will also link against Kani's <code>C</code> library.</li>
<li>For every harness, Kani invokes <code>goto-instrument</code> to prune the linked model to only include items reachable from the given harness.</li>
<li>Finally, Kani instruments and verify each harness model via <code>goto-instrument</code> and <code>cbmc</code> calls.</li>
</ol>
<p>After this RFC, the system flow would be slightly different:</p>
<ol>
<li>Kani compiles the user crate dependencies up to the MIR translation.
I.e., for every crate compiled, <code>kani-compiler</code> will generate an artifact that includes the MIR representation
of all items in the crate.</li>
<li>Kani will generate the goto-program only while compiling the target user crate.
It will generate one goto-program that includes all items reachable from any harness in the target crate.</li>
<li><code>goto-cc</code> will still be invoked to link the generated model against Kani's <code>C</code> library.</li>
<li>Steps #3 and #4 above will be performed without any change.</li>
</ol>
<p>This feature will require three main changes to Kani which are detailed in the sub-sections below.</p>
<h3 id="kanis-sysroot"><a class="header" href="#kanis-sysroot">Kani's Sysroot</a></h3>
<p>Kani currently uses <code>rustup</code> sysroot to gather information from the standard library constructs.
The artifacts from this <code>sysroot</code> include the MIR for generic items as well as for items that may be included in
a crate compilation (e.g.: functions marked with <code>#[inline]</code> annotation).
The artifacts do not include the MIR for items that have already been compiled to the <code>std</code> shared library.
This leaves a gap that cannot be filled by the <code>kani-compiler</code>;
thus, we are unable to translate these items into goto-program.</p>
<p>In order to fulfill this gap, we must compile the standard library from scratch.
This RFC proposes a similar method to what <a href="https://github.com/rust-lang/miri"><code>MIRI</code></a> implements.
We will generate our own sysroot using the <code>-Z always-encode-mir</code> compilation flag.
This sysroot will be pre-compiled and included in our release bundle.</p>
<p>We will compile <code>kani</code>'s libraries (<code>kani</code> and <code>std</code>) also with <code>-Z always-encode-mir</code>
and with the new sysroot.</p>
<h3 id="cross-crate-reachability-analysis"><a class="header" href="#cross-crate-reachability-analysis">Cross-Crate Reachability Analysis</a></h3>
<p><code>kani-compiler</code> will include a new <code>reachability</code> module to traverse over the local and external MIR items.
This module will <code>monomorphize</code> all generic code as it's performing the traversal.</p>
<p>The traversal logic will be customizable allowing different starting points to be used.
The two options to be included in this RFC is starting from all local harnesses
(tagged with <code>#[kani::proof]</code>) and all public functions in the local crate.</p>
<p>The <code>kani-compiler</code> behavior will be customizable via a new flag:</p>
<pre><code>--reachability=[ harnesses | pub_fns |  none | legacy | tests ]
</code></pre>
<p>where:</p>
<ul>
<li><code>harnesses</code>: Use the local harnesses as the starting points for the reachability analysis.</li>
<li><code>pub_fns</code>: Use the public local functions as the starting points for the reachability analysis.</li>
<li><code>none</code>: This will be the default value if <code>--reachability</code> flag is not provided. It will skip
reachability analysis. No goto-program will be generated.
This will be used to compile dependencies up to the MIR level.
<code>kani-compiler</code> will still generate artifacts with the crate's MIR.</li>
<li><code>tests</code>: Use the functions marked as tests with <code>#[tests]</code> as the starting points for the analysis.</li>
<li><code>legacy</code>: Mimics <code>rustc</code> behavior by invoking
<code>rustc_monomorphizer::collect_and_partition_mono_items()</code> to collect the items to be generated.
This will not include many items that go beyond the crate boundary.
<em>This option was only kept for now for internal usage in some of our compiler tests.</em>
<em>It cannot be used as part of the end to end verification flow, and it will be removed in the future.</em></li>
</ul>
<p>These flags will not be exposed to the final user.
They will only be used for the communication between <code>kani-driver</code> and <code>kani-compiler</code>.</p>
<h3 id="dependencies-vs-target-crate-compilation"><a class="header" href="#dependencies-vs-target-crate-compilation">Dependencies vs Target Crate Compilation</a></h3>
<p>The flags described in the section above will be used by <code>kani-driver</code> to implement the new system flow.
For that, we propose the following mechanism:</p>
<ul>
<li>
<p>For standalone <code>kani</code>, we will pass the option <code>--reachability=harnesses</code> to <code>kani-compiler</code>.</p>
</li>
<li>
<p>For <code>cargo-kani</code>, we will replace</p>
<pre><code>cargo build &lt;FLAGS&gt;
</code></pre>
<p>with:</p>
<pre><code>cargo rustc &lt;FLAGS&gt; -- --reachability=harnesses
</code></pre>
<p>to build everything.
This command will compile all dependencies without the <code>--reachability</code> argument, and it will only pass <code>harnesses</code>
value to the compiler when compiling the target crate.</p>
</li>
</ul>
<h2 id="rational-and-alternatives"><a class="header" href="#rational-and-alternatives">Rational and Alternatives</a></h2>
<p>Not doing anything is not an alternative, since this fixes a major gap in Kani's usability.</p>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<ul>
<li>The MIR linker will allow us to fix the linking issues with Rust's standard library.</li>
<li>Once stabilized, the MIR linker will be transparent to the user.</li>
<li>It will enable more powerful and precise static analysis to <code>kani-compiler</code>.</li>
<li>It won't require any changes to our dependencies.</li>
<li>This will fix the harnesses' dependency on the<code>#[no_mangle]</code> annotation
(<a href="https://github.com/model-checking/kani/issues/661">Issue-661</a>).</li>
</ul>
<h3 id="risks"><a class="header" href="#risks">Risks</a></h3>
<p>Failures in the linking stage would not impact the tool soundness. I anticipate the following failure scenarios:</p>
<ul>
<li>ICE (Internal compiler error): Some logic is incorrectly implemented and the linking stage crashes.
Although this is a bad experience for the user, this will not impact the verification result.</li>
<li>Missing items: This would either result in ICE during code generation or a verification failure if the missing
item is reachable.</li>
<li>Extra items: This shouldn't impact the verification results, and they should be pruned by CBMC's reachability
analysis.
This is already the case today. In extreme cases, this could include a symbol that we cannot compile and cause an ICE.</li>
</ul>
<p>The new reachability code would be highly dependent on the <code>rustc</code> unstable APIs, which could increase
the cost of the upstream synchronization.
That said, the APIs that would be required are already used today.</p>
<p>Finally, this implementation relies on a few unstable options from <code>cargo</code> and <code>rustc</code>.
These APIs are used by other tools such as MIRI, so we don't see a high risk that they would be removed.</p>
<h3 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h3>
<p>The other options explored were:</p>
<ol>
<li>Pre-compile the standard library, and the kani library, and ship the generated <code>*symtab.json</code> files.</li>
<li>Pre-compile the standard library, and the kani library, convert the standard library and dependencies to goto-program
(via<code>symtab2gb</code>) and link them into one single goto-program.
Ship the generated model.</li>
</ol>
<p>Both would still require shipping the compiler metadata (via <code>rlib</code> or <code>rmeta</code>) for the kani library, its
dependencies, and <code>kani_macro.so</code>.</p>
<p>Both alternatives are very similar. They only differ on the artifact that would be shipped.
They require generating and shipping a custom <code>sysroot</code>;
however, there is no need to implement the reachability algorithm.</p>
<p>We implemented a prototype for the MIR linker and one for the alternatives.
Both prototypes generate the sysroot as part of the <code>cargo kani</code> flow.</p>
<p>We performed a small experiment (on a <code>c5.4xlarge</code> ec2 instance running Ubuntu 20.04) to assess the options.</p>
<p>For this experiment, we used the following harness:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(4)]
pub fn check_format() {
    assert!(&quot;2&quot;.parse::&lt;u32&gt;().unwrap() == 2);
}
</code></pre>
<p>The experiment showed that the MIR linker approach is much more efficient.</p>
<p>See the table bellow for the breakdown of time (in seconds) taken for each major step of
the harness verification:</p>
<table><thead><tr><th>Stage</th><th>MIR Linker</th><th>Alternative 1</th></tr></thead><tbody>
<tr><td>compilation</td><td>22.2s</td><td>64.7s</td></tr>
<tr><td>goto-program generation</td><td>2.4s</td><td>90.7s</td></tr>
<tr><td>goto-program linking</td><td>0.8s</td><td>33.2s</td></tr>
<tr><td>code instrumentation</td><td>0.8s</td><td>33.1</td></tr>
<tr><td>verification</td><td>0.5s</td><td>8.5s</td></tr>
</tbody></table>
<p>It is possible that <code>goto-cc</code> time can be improved, but this would also require further experimentation and
expertise that we don't have today.</p>
<p>Every option would require a custom sysroot to either be built or shipped with Kani.
The table below shows the size of the sysroot files for the alternative #2
(goto-program files) vs compiler artifacts (<code>*.rmeta</code> files)
files with <code>-Z always-encode-mir</code> for <code>x86_64-unknown-linux-gnu</code> (on Ubuntu 18.04).</p>
<table><thead><tr><th>File Type</th><th>Raw size</th><th>Compressed size</th></tr></thead><tbody>
<tr><td><code>symtab.json</code></td><td>950M</td><td>26M</td></tr>
<tr><td><code>symtab.out</code></td><td>84M</td><td>24M</td></tr>
<tr><td><code>*.rmeta</code></td><td>92M</td><td>25M</td></tr>
</tbody></table>
<p>These results were obtained by looking at the artifacts generated during the same experiment.</p>
<h2 id="open-questions-1"><a class="header" href="#open-questions-1">Open questions</a></h2>
<ul>
<li><del>Should we build or download the sysroot during <code>kani setup</code>?</del>
We include pre-built MIR artifacts for the <code>std</code> library.</li>
<li><del>What's the best way to enable support to run Kani in the entire <code>workspace</code>?</del>
We decided to run <code>cargo rustc</code> per package.</li>
<li><del>Should we codegen all static items no matter what?</del>
We only generate code for static items that are collected by the reachability analysis.
Static objects can only be initialized via constant function.
Thus, it shouldn't have any side effect.</li>
<li><del>What's the best way to handle <code>cargo kani --tests</code>?</del>
We are going to use the test profile and iterate over all the targets available in the crate:
<ul>
<li><code>cargo rustc --profile test -- --reachability=harnesses</code></li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-1"><a class="header" href="#future-possibilities-1">Future possibilities</a></h2>
<ul>
<li>Split the goto-program into two or more items to optimize compilation result caching.
<ul>
<li>Dependencies: One model will include items from all the crate dependencies.
This model will likely be more stable and require fewer updates.</li>
<li>Target crate: The model for all items in the target crate.</li>
</ul>
</li>
<li>Do the analysis per-harness. This might be adequate once we have a mechanism to cache translations.</li>
<li>Add an option to include external functions to the analysis starting point in order to enable verification when
calls are made from <code>C</code> to <code>rust</code>.</li>
<li>Contribute the reachability analysis code back to upstream.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Function and method stubbing (<code>function_stubbing</code>)</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/1695">https://github.com/model-checking/kani/issues/1695</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/1723">https://github.com/model-checking/kani/pull/1723</a> </li>
<li><strong>Status:</strong> Under Review</li>
<li><strong>Version:</strong> 1</li>
<li><strong>Proof-of-concept:</strong> <a href="https://github.com/aaronbembenek-aws/kani/tree/mir_transform">https://github.com/aaronbembenek-aws/kani/tree/mir_transform</a></li>
</ul>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Allow users to specify that certain functions and methods should be replaced with mock functions (stubs) during verification.</p>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>In scope:</p>
<ul>
<li>Replacing function bodies</li>
<li>Replacing method bodies (which means that the new method body will be executed, whether the method is invoked directly or through a vtable)</li>
</ul>
<p>Out of scope:</p>
<ul>
<li>Replacing type definitions</li>
<li>Replacing macro definitions</li>
<li>Mocking traits</li>
<li>Mocking intrinsics</li>
</ul>
<h2 id="user-impact-2"><a class="header" href="#user-impact-2">User impact</a></h2>
<p>We anticipate that function/method stubbing will have a substantial positive impact on the usability of Kani:</p>
<ol>
<li>Users might need to stub functions/methods containing features that Kani does not support, such as inline assembly.</li>
<li>Users might need to stub functions/methods containing code that Kani supports in principle, but which in practice leads to bad verification performance (for example, if it contains deserialization code).</li>
<li>Users could use stubbing to perform compositional reasoning: prove the behavior of a function/method <code>f</code>, and then in other proofs---that call <code>f</code> indirectly---use a stub of <code>f</code> that mocks that behavior but is less complex.</li>
</ol>
<p>In all cases, stubbing would enable users to verify code that cannot currently be verified by Kani (or at least not within a reasonable resource bound).
Even without stubbing types, the ability to stub functions/methods can help provide verification-friendly abstractions for standard data structures.
For example, <a href="https://github.com/model-checking/kani/issues/1673">Issue 1673</a> suggests that some Kani proofs run more quickly if <code>Vec::new</code> is replaced with <code>Vec::with_capacity</code>; function stubbing would allow us to make this substitution everywhere in a codebase (and not just in the proof harness).</p>
<p>In what follows, we give an example of stubbing external code, using the annotations we propose in this RFC.
We are able to run this example on a modified version of Kani using a proof-of-concept MIR-to-MIR transformation implementing stubbing (the prototype does not support stub-related annotations; instead, it reads the stub mapping from a file).
This example stubs out a function that returns a random number.
This is the type of function that is commonly stubbed in other verification and program analysis projects, along with system calls, timer functions, logging calls, and deserialization methods---all of which we should be able to handle.
See the appendix at the end of this RFC for an extended example involving stubbing out a deserialization method.</p>
<h3 id="mocking-randomization"><a class="header" href="#mocking-randomization">Mocking randomization</a></h3>
<p>The crate <a href="https://crates.io/crates/rand"><code>rand</code></a> is widely used (150M downloads).
However, Kani cannot currently handle code that uses it (Kani users have run into this; see <a href="https://github.com/model-checking/kani/issues/1727">Issue 1727</a>.
Consider this example:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn random_cannot_be_zero() {
    assert_ne!(rand::random::&lt;u32&gt;(), 0);
}
</code></pre>
<p>For unwind values less than 2, Kani encounters an unwinding assertion error (there is a loop used to seed the random number generator); if we set an unwind value of 2, Kani fails to terminate within 5 minutes.</p>
<p>Using stubbing, we can specify that the function <code>rand::random</code> should be replaced with a mocked version:</p>
<pre><code class="language-rust">#[cfg(kani)]
fn mock_random&lt;T: kani::Arbitrary&gt;() -&gt; T {
    kani::any()
}

#[cfg(kani)]
#[kani::proof]
#[kani::stub(rand::random, mock_random)]
fn random_cannot_be_zero() {
    assert_ne!(rand::random::&lt;u32&gt;(), 0);
}
</code></pre>
<p>Under this substitution, Kani has a single check, which proves that the assertion can fail. Verification time is 0.02 seconds.</p>
<h2 id="user-experience-2"><a class="header" href="#user-experience-2">User experience</a></h2>
<p>This feature is currently limited to stubbing functions and methods.
We anticipate that the annotations we propose here could also be used for stubbing types, although the underlying technical approach might have to change.</p>
<p>Stubs will be specified per harness; that is, different harnesses can use different stubs.
This is one of the main design points.
Users might want to mock the behavior of a function within one proof harness, and then mock it a different way for another harness, or even use the original function definition.
It would be overly restrictive to impose the same stub definitions across all proof harnesses.
A good example of this is compositional reasoning: in some harnesses, we want to prove properties of a particular function (and so want to use its actual implementation), and in other harnesses we want to assume that that function has those properties.</p>
<p>Users will specify stubs by attaching the <code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code> attribute to each harness function.
The arguments <code>original</code> and <code>replacement</code> give the names of functions/methods.
They will be resolved using Rust's standard name resolution rules; this includes supporting imports like <code>use foo::bar as baz</code>, as well as imports of multiple versions of the same crate (in which case a name would resolve to a function/method in a particular version).
The attribute may be specified multiple times per harness, so that multiple (non-conflicting) stub pairings are supported.</p>
<p>For example, this code specifies that the function <code>mock_random</code> should be used in place of the function <code>rand::random</code> and the function <code>my_mod::bar</code> should be used in place of the function <code>my_mod::foo</code> for the harness <code>my_mod::my_harness</code>:</p>
<pre><code class="language-rust">#[cfg(kani)]
fn mock_random&lt;T: kani::Arbitrary&gt;() -&gt; T {
    kani::any()
}

mod my_mod {

    fn foo(x: u32) -&gt; u32 { ... }

    fn bar(x: u32) -&gt; u32 { ... }

    #[cfg(kani)]
    #[kani::proof]
    #[kani::stub(rand::random, super::mock_random)]
    #[kani::stub(foo, bar)]
    fn my_harness() { ... }

}
</code></pre>
<p>We will support the stubbing of private functions and methods.
While this provides flexibility that we believe will be necessary in practice, it can also lead to brittle proofs: private functions/methods can change or disappear in even minor version upgrades (thanks to refactoring), and so proofs that depend on them might have a high maintenance burden.
In the documentation, we will discourage stubbing private functions/methods except if absolutely necessary.</p>
<h3 id="stub-sets"><a class="header" href="#stub-sets">Stub sets</a></h3>
<p>As a convenience, we will provide a macro <code>kani::stub_set</code> that allows users to specify sets of stubs that can be applied to multiple harnesses:</p>
<pre><code class="language-rust">kani::stub_set!(my_io_stubs(
    stub(std::fs::read, my_read),
    stub(std::fs::write, my_write),
));
</code></pre>
<p>When declaring a harness, users can use the <code>#[kani::use_stub_set(&lt;stub_set_name&gt;)]</code> attribute to apply the stub set:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
#[kani::use_stub_set(my_io_stubs)]
fn my_harness() { ... }
</code></pre>
<p>The name of the stub set will be resolved through the module path (i.e., they are not global symbols), using Rust's standard name resolution rules.</p>
<p>A similar mechanism can be used to aggregate stub sets:</p>
<pre><code class="language-rust">kani::stub_set!(all_my_stubs(
    use_stub_set(my_io_stubs),
    use_stub_set(my_other_stubs),
));
</code></pre>
<h3 id="error-conditions"><a class="header" href="#error-conditions">Error conditions</a></h3>
<p>Given a set of <code>original</code>-<code>replacement</code> pairs, Kani will exit with an error if</p>
<ol>
<li>a specified <code>original</code> function/method does not exist;</li>
<li>a specified <code>replacement</code> stub does not exist;</li>
<li>the user specifies conflicting stubs for the same harness (e.g., if the same <code>original</code> function is mapped to multiple <code>replacement</code> functions); or</li>
<li>the signature of the <code>replacement</code> stub is not compatible with the signature of the <code>original</code> function/method (see next section).</li>
</ol>
<h3 id="stub-compatibility-and-validation"><a class="header" href="#stub-compatibility-and-validation">Stub compatibility and validation</a></h3>
<p>When considering whether a function/method can be replaced with some given stub, we want to allow some measure of flexibility, while also ensuring that we can provide the user with useful feedback if stubbing results in misformed code.
We consider a stub and a function/method to be compatible if all the following conditions are met:</p>
<ul>
<li>They have the same number of parameters.</li>
<li>They have the same return type.</li>
<li>Each parameter in the stub has the same type as the corresponding parameter in the original function/method.</li>
<li>The stub must have the same number of generic parameters as the original function/method.
However, a generic parameter in the stub is allowed to have a different name than the corresponding parameter in the original function/method.
For example, the stub <code>bar&lt;A, B&gt;(x: A, y: B) -&gt; B</code> is considered to have a type compatible with the function <code>foo&lt;S, T&gt;(x: S, y: T) -&gt; T</code>.</li>
<li>The bounds for each type parameter don't need to match; however, all calls to the original function must also satisfy the bounds of the stub.</li>
</ul>
<p>The final point is the most subtle.
We do not require that a type parameter in the signature of the stub implements the same traits as the corresponding type parameter in the signature of the original function/method.
However, Kani will reject a stub if a trait mismatch leads to a situation where a statically dispatched call to a trait method cannot be resolved during monomorphization.
For example, this restriction rules out the following harness:</p>
<pre><code class="language-rust">fn foo&lt;T&gt;(_x: T) -&gt; bool {
    false
}

trait DoIt {
    fn do_it(&amp;self) -&gt; bool;
}

fn bar&lt;T: DoIt&gt;(x: T) -&gt; bool {
    x.do_it()
}

#[kani::proof]
#[kani::stub(foo, bar)]
fn harness() {
    assert!(foo(&quot;hello&quot;));
}
</code></pre>
<p>The call to the trait method <code>DoIt::do_it</code> is unresolvable in the stub <code>bar</code> when the type parameter <code>T</code> is instantiated with the type <code>&amp;str</code>.
On the other hand, our approach provides some flexibility, such as allowing our earlier example of mocking randomization: both <code>rand::random</code> and <code>my_random</code> have the type <code>() -&gt; T</code>, but in the first case <code>T</code> is restricted such that the type <code>Standard</code> implements <code>Distribution&lt;T&gt;</code>, whereas in the latter case <code>T</code> has to implement <code>kani::Arbitrary</code>.
This trait mismatch is allowed because at this call site <code>T</code> is instantiated with <code>u32</code>, which implements <code>kani::Arbitrary</code>.</p>
<h3 id="pedagogy"><a class="header" href="#pedagogy">Pedagogy</a></h3>
<p>To teach this feature, we will update the documentation with a section on function and method stubbing, including simple examples showing how stubbing can help Kani handle code that currently cannot be verified, as well as a guide to best practices for stubbing.</p>
<h2 id="detailed-design-2"><a class="header" href="#detailed-design-2">Detailed design</a></h2>
<p>We expect that this feature will require changes primarily to <code>kani-compiler</code>, with some less invasive changes to <code>kani-driver</code>.
We will modify <code>kani-compiler</code> to collects stub mapping information (from the harness attributes) before code generation.
Since stubs are specified on a per-harness basis, we need to generate multiple versions of code if all harnesses do not agree on their stub mappings; accordingly, we will update <code>kani-compiler</code> to generate multiple versions of code as appropriate. 
To do the stubbing, we will plug in a new MIR-to-MIR transformation that replaces the bodies of specified functions with their replacements.
This can be achieved via <code>rustc</code>'s query mechanism: if the user wants to replace <code>foo</code> with <code>bar</code>, then when the compiler requests the MIR for <code>foo</code>, we instead return the MIR for <code>bar</code>.
<code>kani-compiler</code> will also be responsible for checking for the error conditions previously enumerated.</p>
<p>We will also need to update the metadata that <code>kani-compiler</code> generates, so that it maps each harness to the generated code that has the right stub mapping for that harness (since there will be multiple versions of generated code).
The metadata will also list the stubs applied in each harness.
<code>kani-driver</code> will need to be updated to process this new type of metadata and invoke the correct generated code for each harness.
We can also update the results report to include the stubs that were used.</p>
<p>We anticipate that this design will evolve and be iterated upon.</p>
<h2 id="rationale-and-alternatives-user-experience"><a class="header" href="#rationale-and-alternatives-user-experience">Rationale and alternatives: user experience</a></h2>
<p>Stubbing is a <em>de facto</em> necessity for verification tools, and the lack of stubbing has a negative impact on the usability of Kani.</p>
<h3 id="benefits-1"><a class="header" href="#benefits-1">Benefits</a></h3>
<ul>
<li>Because stubs are specified by annotating the harness, the user is able to specify stubs for functions they do not have source access to (like library functions).
This contrasts with annotating the function to be replaced (such as with function contracts).</li>
<li>The current design provides the user with flexibility, as they can specify different sets of stubs to use for different harnesses.
This is important if users are trying to perform compositional reasoning using stubbing, since in some harnesses a function/method should be fully verified, in in other harnesses its behavior should be mocked.</li>
<li>The stub selections are located adjacent to the harness, which makes it easy to understand which replacements are going to happen for each harness.</li>
</ul>
<h3 id="risks-1"><a class="header" href="#risks-1">Risks</a></h3>
<ul>
<li>Users can always write stubs that do not correctly correspond to program behavior, and so a successful verification does not actually mean the program is bug-free.
This is similar to other specification bugs.
All the stubbing code will be available, so it is possible to inspect the assumptions it makes.</li>
</ul>
<h3 id="comparison-to-function-contracts"><a class="header" href="#comparison-to-function-contracts">Comparison to function contracts</a></h3>
<ul>
<li>In many cases, stubs are more user-friendly than contracts.
With contracts, it is sometimes necessary to explicitly provide information that is automatically captured in Rust (such as which memory is written).
Furthermore, contract predicates constitute a DSL of their own that needs to be learned; using stubbing, we can stick to using just Rust.</li>
<li>Function contracts sometimes come with a mechanism for verifying that a function satisfies its contract (for example, <a href="http://www.cprover.org/cprover-manual/contracts/functions/">CBMC provides this</a>).
While we do not plan to provide such a feature, it is possible to emulate this by writing proof harnesses comparing the behavior of the original function and the stub.
Furthermore, our approach provides additional flexibility, as it is not always actually desirable for a stub to be an overapproximation of the function (e.g., we might want the stub to exhibit a certain behavior within a particular harness) or to have a consistent behavior across all harnesses.</li>
<li>The <a href="https://github.com/model-checking/kani/tree/features/function-contracts">currently proposed function contract mechanism</a> does not provide a way to specify contracts on external functions.
In principle, it would be possible to extend it to do so.
Doing so would require some additional UX design decisions (e.g., &quot;How do users specify this?&quot;); with stubbing there does not need to be a distinction between local and external functions.</li>
</ul>
<h3 id="alternative-1-annotate-stubbed-functions"><a class="header" href="#alternative-1-annotate-stubbed-functions">Alternative #1: Annotate stubbed functions</a></h3>
<p>In this alternative, users add an attribute <code>#[kani::stub_by(&lt;replacement&gt;)]</code> to the function that should be replaced.
This approach is similar to annotating a function with a contract specifying its behavior (the stub acts like a programmatic contract).
The major downside with this approach is that it would not be possible to stub external code. We see this as a likely use case that needs to be supported: users will want to replace <code>std</code> library functions or functions from arbitrary external crates.</p>
<h3 id="alternative-2-annotate-stubs"><a class="header" href="#alternative-2-annotate-stubs">Alternative #2: Annotate stubs</a></h3>
<p>In this alternative, users add an attribute <code>#[kani::stub_of(&lt;original&gt;)]</code> to the stub function itself, saying which function it replaces:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::stub_of(rand::random)]
fn mock_random&lt;T: kani::Arbitrary&gt;() -&gt; T { ... }
</code></pre>
<p>The downside is that this stub must be uniformly applied across all harnesses and the stub specifications might be spread out across multiple files.
It would also require an extra layer of indirection to use a function as a stub if the user does not have source code access to it.</p>
<h3 id="alternative-3-annotate-harnesses-and-stubs"><a class="header" href="#alternative-3-annotate-harnesses-and-stubs">Alternative #3: Annotate harnesses and stubs</a></h3>
<p>This alternative combines the proposed solution and Alternative #2.
Users annotate the stub (as in Alternative #2) and specify for each harness which stubs to use using an annotation <code>#[kani::use_stubs(&lt;stub&gt;+)]</code> placed above the harness.</p>
<p>This could be combined with modules, so that a module can be used to group stubs together, and then harnesses could pull in all the stubs in the module:</p>
<pre><code class="language-rust">#[cfg(kani)]
mod my_stubs {

  #[kani::stub_of(foo)]
  fn stub1() { ... }

  #[kani::stub_of(bar)]
  fn stub2() { ... }

}

#[cfg(kani)]
#[kani::proof]
#[kani::use_stubs(my_stubs)]
fn my_harness() { ... }
</code></pre>
<p>The benefit is that stubs are specified per harness, and (using modules) it might be possible to group stubs together.
The downside is that multiple annotations are required and the stub mappings themselves are remote from the harness (at the harness you would know what stub is being used, but not what it is replacing).
There are also several issues that would need to be resolved:</p>
<ul>
<li>How do you mock multiple functions with the same stub?
(Say harness A wants to use <code>stub1</code> to mock <code>foo</code>, and harness B wants to use <code>stub1</code> to mock <code>bar</code>.)</li>
<li>How do you combine stub sets defined via modules? Would you use the module hierarchy?</li>
<li>If you use modules to define stub sets, are these modules regular modules or not?
In particular, given that modules can contain other constructs than functions, how should we interpret the extra stuff?</li>
</ul>
<h3 id="alternative-4-specify-stubs-in-a-file"><a class="header" href="#alternative-4-specify-stubs-in-a-file">Alternative #4: Specify stubs in a file</a></h3>
<p>One alternative would be to specify stubs in a file that is passed to <code>kani-driver</code> via a command line option.
Users would specify per-harness stub pairings in the file; JSON would be a possible format.
Using a file would eliminate the need for <code>kani-compiler</code> to do an extra pass to extract harness information from the Rust source code before doing code generation; the rest of the implementation would stay the same.
It would also allow the same harness to be run with different stub selections (by supplying a different file).
The disadvantage is that the stub selection is remote from the harness itself.</p>
<h2 id="rationale-and-alternatives-stubbing-mechanism"><a class="header" href="#rationale-and-alternatives-stubbing-mechanism">Rationale and alternatives: stubbing mechanism</a></h2>
<p>Our approach is based on a MIR-to-MIR transformation.
Some advantages are that it operates over a relatively simple intermediate representation and <code>rustc</code> has good support for plugging in MIR-to-MIR transformations, so it would not require any changes to <code>rustc</code> itself.
At this stage of the compiler, names have been fully resolved, and there is no problem with swapping in the body of a function defined in one crate for a function defined in another.
Another benefit is that it should be possible to extend the compiler to integrate <code>--concrete-playback</code> with the abstractions (although doing so is out of scope for the current proposal).</p>
<p>The major downside with the MIR-to-MIR transformation is that it does not appear to be possible to stub types at that stage (there is no way to change the definition of a type through the MIR).
Thus, our proposed approach will not be a fully general stubbing solution.
However, it is technically feasible and relatively clean, and provides benefits over having no stubbing at all (as can be seen in the examples in the first part of this document).</p>
<p>Furthermore, it could be used as part of a portfolio of stubbing approaches, where users stub local types using conditional compilation (see Alternative #1), and Kani provides a modified version of the standard library with verification-friendly versions of types like <code>std::vec::Vec</code>.</p>
<h3 id="alternative-1-conditional-compilation"><a class="header" href="#alternative-1-conditional-compilation">Alternative #1: Conditional compilation</a></h3>
<p>In this baseline alternative, we do not provide any stubbing mechanism at all.
Instead, users can effectively stub local code (functions, methods, and types) using conditional compilation.
For example, they could specify using <code>#[cfg(kani)]</code> to turn off the original definition and turn on the replacement definition when Kani is running, similarly to the ghost state approach taken in the <a href="https://model-checking.github.io/kani-verifier-blog/2022/08/17/using-the-kani-rust-verifier-on-tokio-bytes.html">Tokio Bytes proof</a>.</p>
<p>The disadvantage with this approach is that it does not provide any way to stub external code, which is one of the main motivations of our proposed approach.</p>
<h3 id="alternative-2-source-to-source-transformation"><a class="header" href="#alternative-2-source-to-source-transformation">Alternative #2: Source-to-source transformation</a></h3>
<p>In this alternative, we rewrite the source code before it even gets to the compiler.
The advantage with this approach is that it is very flexible, allowing us to stub functions, methods, and types, either by directly replacing them, or appending their replacements and injecting appropriate conditional compilation guards.</p>
<p>This approach entails less user effort than Alternative #1, but it has the same downside that it requires all source code to be available.
It also might be difficult to inject code in a way that names are correctly resolved (e.g., if the replacement code comes from a different crate).
Also, source code is difficult to work with (e.g., unexpanded macros).</p>
<p>On the last two points, we might be able to take advantage of an existing source analysis platform like <code>rust-analyzer</code> (which has facilities like structural search replace), but this would add more (potentially fragile) dependencies to Kani.</p>
<h3 id="alternative-3-ast-to-ast-or-hir-to-hir-transformation"><a class="header" href="#alternative-3-ast-to-ast-or-hir-to-hir-transformation">Alternative #3: AST-to-AST or HIR-to-HIR transformation</a></h3>
<p>In this alternative, we implement stubbing by rewriting the <a href="https://rustc-dev-guide.rust-lang.org/syntax-intro.html">AST</a> or <a href="https://rustc-dev-guide.rust-lang.org/hir.html">High-Level IR (HIR)</a> of the program.
The HIR is a more compiler-friendly version of the AST; it is what is used for type checking.
To swap out a function, method, or type at this level, it looks like it would be necessary to add another pass to <code>rustc</code> that takes the initial AST/HIR and produces a new AST/HIR with the appropriate replacements.</p>
<p>The advantage with this approach is, like source transformations, it would be very flexible.
The downside is that it would require modifying <code>rustc</code> (as far as we know, there is not an API for plugging in a new AST/HIR pass), and would also require performing the transformations at a very syntactic level: although the AST/HIR would likely be easier to work with than source code directly, it is still very close to the source code and not very abstract.
Furthermore, provided we supported stubbing across crate boundaries, it seems like we would run into a sequencing issue: if we were trying to stub a function in a dependency, we might not know until after we have compiled that dependency that we need to modify its AST/HIR; furthermore, even if we were aware of this, the replacement AST/HIR code would not be available at that time (the AST/HIR is usually just constructed for the crate currently being compiled).</p>
<h2 id="open-questions-2"><a class="header" href="#open-questions-2">Open questions</a></h2>
<ul>
<li>Would there ever be the need to stub a particular monomorphization of a function, as opposed to the polymorphic function?</li>
<li>How can the user verify that the stub is an abstraction of the original function/method?
Sometimes it might be important that a stub is an overapproximation or underapproximation of the replaced code. 
One possibility would be writing proofs about stubs (possibly relating their behavior to that of the code they are replacing).</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Our proposed approach will not work with <code>--concrete-playback</code> (for now).</li>
<li>We are only able to apply abstractions to some dependencies if the user enables the MIR linker.</li>
</ul>
<h2 id="future-possibilities-2"><a class="header" href="#future-possibilities-2">Future possibilities</a></h2>
<ul>
<li>
<p>It would increase the utility of stubbing if we supported stubs for types.
The source code annotations could likely stay the same, although the underlying technical approach performing these substitutions might be significantly more complex.</p>
</li>
<li>
<p>It would probably make sense to provide a library of common stubs for users, since many applications might want to stub the same functions and mock the same behaviors (e.g., <code>rand::random</code> can be replaced with a function returning <code>kani::any</code>).</p>
</li>
<li>
<p>We could provide special classes of stubs that are likely to come up in practice:</p>
<ul>
<li><code>unreachable</code>: assert the function is unreachable.</li>
<li><code>havoc_locals</code>: return nondeterministic values and assign nondeterministic values to all mutable arguments.</li>
<li><code>havoc</code>: similar to <code>havoc_locals</code> but also assign nondeterministic values to all mutable global variables.</li>
<li><code>uninterpret</code>: treat function as an uninterpreted function.</li>
</ul>
</li>
<li>
<p>How can we provide a good user experience for accessing private fields of <code>self</code> in methods?
It is possible to do so using <code>std::mem::transmute</code> (see below); this is clunky and error-prone, and it would be good to provide better support for users.</p>
<pre><code class="language-rust">struct Foo {
    x: u32,
}

impl Foo {
    pub fn m(&amp;self) -&gt; u32 {
        0
    }
}

struct MockFoo {
    pub x: u32,
}

fn mock_m(foo: &amp;Foo) {
    let mock: &amp;MockFoo = unsafe { std::mem::transmute(foo) };
    return mock.x;
}

#[cfg(kani)]
#[kani::proof]
#[kani::stub(Foo::m, mock_m)]
fn my_harness() { ... }
</code></pre>
</li>
</ul>
<h2 id="appendix-an-extended-example"><a class="header" href="#appendix-an-extended-example">Appendix: an extended example</a></h2>
<p>In this example, we mock a <a href="https://crates.io/crates/serde_json">serde_json</a> (96M downloads) deserialization method so that we can prove a property about the following <a href="https://github.com/firecracker-microvm/firecracker/blob/01eba51ded2f5439da91a2d73280f579651b067c/src/api_server/src/request/vsock.rs#L11">Firecracker function</a> that parses a configuration from some raw data:</p>
<pre><code class="language-rust">fn parse_put_vsock(body: &amp;Body) -&gt; Result&lt;ParsedRequest, Error&gt; {
    METRICS.put_api_requests.vsock_count.inc();
    let vsock_cfg = serde_json::from_slice::&lt;VsockDeviceConfig&gt;(body.raw()).map_err(|err| {
        METRICS.put_api_requests.vsock_fails.inc();
        err
    })?;

    // Check for the presence of deprecated `vsock_id` field.
    let mut deprecation_message = None;
    if vsock_cfg.vsock_id.is_some() {
        // vsock_id field in request is deprecated.
        METRICS.deprecated_api.deprecated_http_api_calls.inc();
        deprecation_message = Some(&quot;PUT /vsock: vsock_id field is deprecated.&quot;);
    }

    // Construct the `ParsedRequest` object.
    let mut parsed_req = ParsedRequest::new_sync(VmmAction::SetVsockDevice(vsock_cfg));
    // If `vsock_id` was present, set the deprecation message in `parsing_info`.
    if let Some(msg) = deprecation_message {
        parsed_req.parsing_info().append_deprecation_message(msg);
    }

    Ok(parsed_req)
}
</code></pre>
<p>We manually mocked some of the Firecracker types with simpler versions to reduce the number of dependencies we had to pull in (e.g., we removed some enum variants, unused struct fields).
With these changes, we were able to prove that the configuration data has a vsock ID if and only if the parsing metadata includes a deprecation message: </p>
<pre><code class="language-rust">#[cfg(kani)]
fn get_vsock_device_config(action: RequestAction) -&gt; Option&lt;VsockDeviceConfig&gt; {
    match action {
        RequestAction::Sync(vmm_action) =&gt; match *vmm_action {
            VmmAction::SetVsockDevice(dev) =&gt; Some(dev),
            _ =&gt; None,
        },
        _ =&gt; None,
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(2)]
#[kani::stub(serde_json::deserialize_slice, mock_deserialize)]
fn test_deprecation_vsock_id_consistent() {
    // We are going to mock the parsing of this body, so might as well use an empty one.
    let body: Vec&lt;u8&gt; = Vec::new();
    if let Ok(res) = parse_put_vsock(&amp;Body::new(body)) {
        let (action, mut parsing_info) = res.into_parts();
        let config = get_vsock_device_config(action).unwrap();
        assert_eq!(
            config.vsock_id.is_some(),
            parsing_info.take_deprecation_message().is_some()
        );
    }
}
</code></pre>
<p>Crucially, we did this by stubbing out <code>serde_json::from_slice</code> and replacing it with our mock version below, which ignores its input and creates a &quot;symbolic&quot; configuration struct:</p>
<pre><code class="language-rust">#[cfg(kani)]
fn symbolic_string(len: usize) -&gt; String {
    let mut v: Vec&lt;u8&gt; = Vec::with_capacity(len);
    for _ in 0..len {
        v.push(kani::any());
    }
    unsafe { String::from_utf8_unchecked(v) }
}

#[cfg(kani)]
fn mock_deserialize(_data: &amp;[u8]) -&gt; serde_json::Result&lt;VsockDeviceConfig&gt; {
    const STR_LEN: usize = 1;
    let vsock_id = if kani::any() {
        None
    } else {
        Some(symbolic_string(STR_LEN))
    };
    let guest_cid = kani::any();
    let uds_path = symbolic_string(STR_LEN);
    let config = VsockDeviceConfig {
        vsock_id,
        guest_cid,
        uds_path,
    };
    Ok(config)
}
</code></pre>
<p>The proof takes 170 seconds to complete (using Kissat as the backend SAT solver for CBMC).</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Cover statement <code>cover_statement</code></li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/696">https://github.com/model-checking/kani/issues/696</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/1906">https://github.com/model-checking/kani/pull/1906</a></li>
<li><strong>Status:</strong> Under Review</li>
<li><strong>Version:</strong> 0</li>
<li><strong>Proof-of-concept:</strong> <em>Optional field. If you have implemented a proof of concept, add a link here</em></li>
</ul>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>A new Kani API that allows users to check that a certain condition can occur at a specific location in the code.</p>
<h2 id="user-impact-3"><a class="header" href="#user-impact-3">User Impact</a></h2>
<p>Users typically want to gain confidence that a proof checks what it is supposed to check, i.e. that properties are not passing vacuously due to an over-constrained environment.</p>
<p>A new Kani macro, <code>cover</code> will be created that can be used for checking that a certain condition <em>can</em> occur at a specific location in the code.
The purpose of the macro is to verify, for example, that assumptions are not ruling out those conditions, e.g.:</p>
<pre><code class="language-rust">let mut v: Vec&lt;i32&gt; = Vec::new();
let len: usize = kani::any();
kani::assume(len &lt; 5);
for _i in 0..len {
    v.push(kani::any());
}
// make sure we can get a vector of length 5
kani::cover!(v.len() == 5);
</code></pre>
<p>This is typically used to ensure that verified checks are not passing <em>vacuously</em>, e.g. due to overconstrained pre-conditions.</p>
<p>The special case of verifying that a certain line of code is reachable can be achieved using <code>kani::cover!()</code> (which is equivalent to <code>cover!(true)</code>), e.g.</p>
<pre><code class="language-rust">match x {
    val_1 =&gt; ...,
    val_2 =&gt; ...,
    ...
    val_i =&gt; kani::cover!(), // verify that `x` can take the value `val_i`
}
</code></pre>
<p>Similar to Rust's <code>assert</code> macro, a custom message can be specified, e.g.</p>
<pre><code class="language-rust">kani::cover!(x &gt; y, &quot;x can be greater than y&quot;);
</code></pre>
<h2 id="user-experience-3"><a class="header" href="#user-experience-3">User Experience</a></h2>
<p>The <code>cover</code> macro instructs Kani to find <em>at least one</em> possible execution that satisfies the specified condition at that line of code.  If no such execution is possible, the check is reported as <em>unsatisfiable</em>.</p>
<p>Each cover statement will be reported as a check whose description is <code>cover condition: cond</code> and whose status is:</p>
<ul>
<li><code>SATISFIED</code> (green): if Kani found an execution that satisfies the condition.</li>
<li><code>UNSATISFIABLE</code> (yellow): if Kani proved that the condition cannot be satisfied.</li>
<li><code>UNREACHABLE</code> (yellow): if Kani proved that the cover statement itself cannot be reached.</li>
</ul>
<p>For example, for the following <code>cover</code> statement:</p>
<pre><code class="language-rust">kani::cover!(a == 0);
</code></pre>
<p>An example result is:</p>
<pre><code>Check 2: main.cover.2
         - Status: SATISFIED
         - Description: &quot;cover condition: a == 0&quot;
         - Location: foo.rs:9:5 in function main
</code></pre>
<h3 id="impact-on-overall-verification-status"><a class="header" href="#impact-on-overall-verification-status">Impact on Overall Verification Status</a></h3>
<p>By default, unsatisfiable and unreachable <code>cover</code> checks will not impact verification success or failure.
This is to avoid getting verification failure for harnesses for which a <code>cover</code> check is not relevant.
For example, on the following program, verification should not fail for <code>another_harness_that_doesnt_call_foo</code> because the <code>cover</code> statement in <code>foo</code> is unreachable from it.</p>
<pre><code class="language-rust">[kani::proof]
fn a_harness_that_calls_foo() {
    foo();
}

#[kani::proof]
fn another_harness_that_doesnt_call_foo() {
    // ...
}

fn foo() {
    kani::cover!( /* some condition */);
}
</code></pre>
<p>We can consider adding an option that would cause verification to fail if a cover property was unsatisfiable or unreachable, e.g. <code>--fail-uncoverable</code>.</p>
<h3 id="inclusion-in-the-verification-summary"><a class="header" href="#inclusion-in-the-verification-summary">Inclusion in the Verification Summary</a></h3>
<p>Cover checks will be reported separately in the verification summary, e.g.</p>
<pre><code>SUMMARY:
 ** 1 of 206 failed (2 unreachable)
 Failed Checks: assertion failed: x[0] == x[1]

 ** 30 of 35 cover statements satisfied (1 unreachable) &lt;--- NEW
</code></pre>
<p>In this example, 5 of the 35 cover statements were found to be unsatisfiable, and one of those 5 is additionally unreachable.</p>
<h3 id="interaction-with-other-checks"><a class="header" href="#interaction-with-other-checks">Interaction with Other Checks</a></h3>
<p>If one or more unwinding assertions fail or an unsupported construct is found to be reachable (which indicate an incomplete path exploration), and Kani found the condition to be unsatisfiable or unreachable, the result will be reported as <code>UNDETERMINED</code>.</p>
<h2 id="detailed-design-3"><a class="header" href="#detailed-design-3">Detailed Design</a></h2>
<p>The implementation will touch the following components:</p>
<ul>
<li>Kani library: The <code>cover</code> macro will be added there along with a <code>cover</code> function with a <code>rustc_diagnostic_item</code></li>
<li><code>kani-compiler</code>: The <code>cover</code> function will be handled via a hook and codegen as two assertions (<code>cover(cond)</code> will be codegen as <code>__CPROVER_assert(false); __CPROVER_assert(!cond)</code>).
The purpose of the <code>__CPROVER_assert(false)</code> is to determine whether the <code>cover</code> statement is reachable.
If it is, the second <code>__CPROVER_assert(!cond)</code> indicates whether the condition is satisfiable or not.</li>
<li><code>kani-driver</code>: The CBMC output parser will extract cover properties through their property class, and their result will be set based on the result of the two assertions:
<ul>
<li>The first (reachability) assertion is proven: report as <code>FAILURE (UNREACHABLE)</code></li>
<li>The first assertion fails, and the second one is proven: report as <code>FAILURE</code> to indicate that the condition is unsatisfiable</li>
<li>The first assertion fails, and the second one fails: report as <code>SUCCESS</code> to indicate that the condition is satisfiable</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-1"><a class="header" href="#rationale-and-alternatives-1">Rationale and alternatives</a></h2>
<ul>
<li>
<p>What are the pros and cons of this design?
CBMC has its own <a href="https://diffblue.github.io/cbmc//cprover__builtin__headers_8h.html#a44f072b21e93cb0f72adcccc9005f307">cover API (<code>__CPROVER_cover</code>)</a>, for which <code>SUCCESS</code> is reported if an execution is found, and <code>FAILURE</code> is reported otherwise.
However, using this API currently requires running CBMC in a separate <a href="https://github.com/diffblue/cbmc/issues/6613">&quot;cover&quot; mode</a>.
Having to run CBMC in that mode would complicate the Kani driver as it will have to perform two CBMC runs, and then combine their results into a single report.
Thus, the advantage of the proposed design is that it keeps the Kani driver simple.
In addition, the proposed solution does not depend on a feature in the backend, and thus will continue to work if we were to integrate a different backend.</p>
</li>
<li>
<p>What is the impact of not doing this?
The current workaround to accomplish the same effect of verifying that a condition can be covered is to use <code>assert!(!cond)</code>.
However, if the condition can indeed be covered, verification would fail due to the failure of the assertion.</p>
</li>
</ul>
<h2 id="open-questions-3"><a class="header" href="#open-questions-3">Open questions</a></h2>
<p>Should we allow format arguments in the macro, e.g. <code>kani::cover!(x &gt; y, &quot;{} can be greater than {}&quot;, x, y)</code>?
Users may expect this to be supported since the macro looks similar to the <code>assert</code> macro, but Kani doesn't include the formatted string in the message description, since it's not available at compile time.</p>
<h2 id="other-considerations"><a class="header" href="#other-considerations">Other Considerations</a></h2>
<p>We need to make sure the concrete playback feature can be used with <code>cover</code> statements that were found to be coverable.</p>
<h2 id="future-possibilities-3"><a class="header" href="#future-possibilities-3">Future possibilities</a></h2>
<p>The new cover API subsumes the current <code>kani::expect_fail</code> function.
Once it's implemented, we should be able to get rid of <code>expect_fail</code>, and all the related code in <code>compiletest</code> that handles the <code>EXPECTED FAILURE</code> message in a special manner.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0005-should-panic-attr"><a class="header" href="#0005-should-panic-attr">0005-should-panic-attr</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
